from typing import Callable, Tuple, TypeVar, Generic
from result import Result


T = TypeVar('T')
U = TypeVar('U')
E = TypeVar('E')


class Option(Generic[T]):
    def __init__(self, obj: T) -> None: ...
    @property
    def value(self) -> T: ...
    def is_some(self) -> bool: ...
    def is_some_and(self, f: Callable[[T], bool]) -> bool: ...
    def is_none(self) -> bool: ...
    def expect(self, msg: str) -> T: ...
    def unwrap(self) -> T: ...
    def unwrap_or(self, default: T) -> T: ...
    def unwrap_or_else(self, f: Callable[[], T]) -> T: ...
    def map(self, f: Callable[[T], U]) -> Option[U]: ...
    def inspect(self, f: Callable[[T],]) -> Option: ...
    def map_or(self, default: U, f: Callable[[T], U]) -> U: ...
    def map_or_else(self, default: Callable[[], U], f: Callable[[T], U]) -> U: ...
    def ok_or(self, err: E) -> Result: ...
    def ok_or_else(self, err: Callable[[], E]) -> Result: ...
    def and_then(self, f: Callable[[T], Option[U]]) -> Option[U]: ...
    def or_else(self, f: Callable[[], Option[T]]) -> Option[T]: ...
    def zip(self, other: Option[U]) -> Option[Tuple[T, U]]: ...
    def transpose(self) -> Result[Option[T]]: ...
    def flatten(self) -> Option[T]: ...