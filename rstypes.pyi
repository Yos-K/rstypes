from typing import Callable, Tuple, TypeVar, Generic


T = TypeVar('T')
U = TypeVar('U')
E = TypeVar('E')


class Option(Generic[T]):
    def __init__(self, obj: T) -> None: ...
    @property
    def value(self) -> T: ...
    def is_some(self) -> bool: ...
    def is_some_and(self, f: Callable[[T], bool]) -> bool: ...
    def is_none(self) -> bool: ...
    def expect(self, msg: str) -> T: ...
    def unwrap(self) -> T: ...
    def unwrap_or(self, default: T) -> T: ...
    def unwrap_or_else(self, f: Callable[[], T]) -> T: ...
    def map(self, f: Callable[[T], U]) -> Option[U]: ...
    def inspect(self, f: Callable[[T],]) -> Option: ...
    def map_or(self, default: U, f: Callable[[T], U]) -> U: ...
    def map_or_else(self, default: Callable[[], U], f: Callable[[T], U]) -> U: ...
    def ok_or(self, err: E) -> Result[T, E]: ...
    def ok_or_else(self, err: Callable[[], E]) -> Result[T, E]: ...
    def and_then(self, f: Callable[[T], Option[U]]) -> Option[U]: ...
    def or_else(self, f: Callable[[], Option[T]]) -> Option[T]: ...
    def zip(self, other: Option[U]) -> Option[Tuple[T, U]]: ...


class Result:
    class Ok(Generic[T]):
        def __init__(self, value: T) -> None: ...
        def is_ok(self) -> bool: ...
        def is_ok_and(self, f: Callable[[T], bool]) -> bool: ...
        def is_err(self) -> bool: ...
        def is_err_and(self, f: Callable[[T], bool]) -> bool: ...
        def ok(self) -> Option[T]: ...
        def err(self) -> Option[E]: ...
        def map(self, f: Callable[[T], U]) -> Result.Ok[U]: ...
        def map_or(self, default: U, f: Callable[[T], U]) -> U: ...
        def map_or_else(self, default: Callable[[], U], f: Callable[[T], U]) -> U: ...

    class Err(Generic[T]):
        def __init__(self, value: T) -> None: ...
        def is_ok(self) -> bool: ...
        def is_ok_and(self, f: Callable[[T], bool]) -> bool: ...
        def is_err(self) -> bool: ...
        def is_err_and(self, f: Callable[[T], bool]) -> bool: ...
        def ok(self) -> Option[T]: ...
        def err(self) -> Option[E]: ...
        def map(self, f: Callable[[T], U]) -> Result.Err[U]: ...
        def map_or(self, default: U, f: Callable[[T], U]) -> U: ...
        def map_or_else(self, default: Callable[[], U], f: Callable[[T], U]) -> U: ...
        def map_err(self, op: Callable[[T], U]) -> Result[U]: ...
